# 3D Scanner Planning Document

This is a planning document/journal for the 3D scanner project.

## Getting the scanner to work

We use a SHARP GP2Y0A21YK0F IR distance sensor. [Datasheet](https://global.sharp/products/device/lineup/data/pdf/datasheet/gp2y0a21yk_e.pdf).

### Parts
![IMG_3144.jpeg](IMG_3144.jpeg)

### Circuit Layout
![IMG_3148.jpeg](IMG_3148.jpeg)

### Code
This code reads the raw voltage value, converts it to a distance, and sends it to serial.

_This code was generated by AI_

```cpp
void setup() {
    Serial.begin(9600);
}

float computeDistance(float voltage) {
    return pow( voltage / 15.80314 , 1.0 / -0.836479 );
}

void loop() {
    int raw = analogRead(A1);                     // 0–1023
    float voltage = raw * (5.0 / 1023.0);         // convert to volts
    float distance = computeDistance(voltage);

    Serial.println(distance, 2);                  // cm, 2 dp
    delay(100);
}
```

This is code used for validation or calibration purposes. Every time an input distance is entered the program displays that distance alongside the calculated measured distance and voltage. It reuses `computeDistance` from the above snippet. The function used to convert voltage to distance is an exponential function obtained by exponential regression on points from a relevant graph on the datasheet. Ideally one would calibrate said exponential function with a simple testing setup but this would take too much time.

_This code was generated by AI_

```cpp
void setup() {
    Serial.begin(9600);
    while (!Serial) {}

    // CSV header for saving to file
    Serial.println("actual_cm,raw_adc,computed_cm");

    Serial.println("Enter actual distance in cm:");
}

float computeDistance(int raw) {
    // convert ADC value (0–1023) to volts
    float voltage = raw * (5.0 / 1023.0);

    // your fitted curve
    float d = 15.80314 * pow(voltage, -0.836479);

    return d;
}

void loop() {
    static String buf = "";

    while (Serial.available() > 0) {
        char c = Serial.read();

        if (c == '\n') {
            float actual = buf.toFloat();

            // take sensor reading
            int raw = analogRead(A1);
            float measured = computeDistance(raw);

            // CSV line for logging
            Serial.print(actual, 2);
            Serial.print(",");
            Serial.print(raw);
            Serial.print(",");
            Serial.println(measured, 2);

            Serial.println("Enter next actual distance:");
            buf = "";
        }
        else if (c != '\r') {
            buf += c;
        }
    }
}
```

## Moving the sensor

A sensor in place does not do much. To create a functioning 3D scanner one must either move the scanner or the space/object being scanned. Three options were considered:

 - A turret mechanism to move the sensor in pitch and yaw to scan a scene in front of the sensor.
 - A dropping turntable that would allow the sensor to capture 360-degree slices of an object on the turntable.
 - Strap the sensor onto a 6-DOF inertial measurement unit.

Option 3 was quickly dismissed for lack of resources. Between option 1 and 2, option 1 was probably the easier one to implement and more importantly took up a lower volume, so it was considered first.

### Moving the stepper

The stepper interfaces with the arduino via a [CNC Shield from Makerstore](https://www.makerstore.com.au/wp-content/uploads/filebase/publications/CNC-Shield-Guide-v1.0.pdf) and a [A4988 Stepper Driver](https://makerstore.cc/product/stepper-motor-driver-a4988/).

### Mechanical connection

To convert motor movements into yaw and pitch would essentially require two L-brackets, one motor to motor and one motor to scanner. These were initially 3D printed but laser cutting was eventually preferred due to faster production and iteration speed. The final laser-cut design involved a lot of captured nuts to hold both the bracket together and also in place of a stepper hub. The drawing of half of the motor to motor bracket that includes the "motor hub" is shown below.

![m2m.png](m2m.png)

## Integration into Product

There was less of an emphasis on creating a "nice" product and the focus was more in getting the sensor to move, take readings, and display its outputs correctly.

### Wiring

A full setup is shown below. This involves 4 total laser-cut parts.

![IMG_3309.jpeg](IMG_3309.jpeg)

As is pretty obvious the connections are taped and not done in a very sophisticated or robust way. No wire organisation was ever considered. The sensor was plugged into the CNC shield. 

### Code

See [https://github.com/PatrickJYKang/3d-scanner](https://github.com/PatrickJYKang/3d-scanner). This repository includes both code to run the stepper and sensor off the arduino, as well as python code to read input off of serial and plot it.

### Results

An example screenshot of the results is shown below.

![out1.png](out1.png)

In general, the setup is good at identifying flat and perpendicular surfaces, but struggles with curved or slanted/tilted surfaces. It is also capable of rather precisely tracing holes in objects, as shown in the below example.

![out2.png](out2.png)

That said, the most prominent issue affecting these readings seems to be stray points going in all directions especially at edge of objects. This is a common issue known as "flying pixels". Generally these are mitigated through post-processing software fixes. 
